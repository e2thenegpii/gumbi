#summary Documentation on the Gumbi configuration file format

= Configuration Class =

The Gumbi API includes a Configuration class which is responsible for parsing configuration files used by Gumbi based applications. While it does look for specific fields that are common to most Gumbi applications, it is generic enough to be used for parsing customized configuration files as well.

= Configuration File Format =

Configuration files are expected to contain one entry per line, in the format of KEY=VALUE. Any text preceded by a pound sign (#) will be considered a comment and ignored. White space is allowed, and while KEY strings are case insensitive it is good convention to make them all upper case.

If multiple values need to be provided for a given key, they may be separated by any of the following separators:

  * ,
  * :
  * ;

Example:

{{{
# This configuration file is for use in Gumbi's parallel mode
MODE=parallel

#Enable the 3 volt on board regulator
VOLTAGE = 3 

# Specify a list of address pins
ADDRESS=1,2,3,4

# This is a custom key value.
FOO=bar
}}}

= Built In Keys =

There are several configuration keys that have special meaning. Many of these are primarily applicable when operating in parallel mode, but they can be used by any mode of operation.

|| *Key* || *Description* || *Accepted Values* ||
|| VOLTAGE || The voltage regulator to enable. This value may be any valid value accepted by Gumbi.SetVoltage. If specified in the configuration file, the selected voltage regulator will be automatically enabled. If not specified, the currently enabled voltage regulator will be used. || One of: 0, 2, 3, 5 ||
|| PINS || The pin count of the target device, used internally for automatic pin mapping. For example, if an 8 pin chip is plugged into the Gumbi board, chip pin 1 will be connected to Gumbi pin 1 while chip pin 8 will be connected to Gumbi pin 64. If this key is defined, the mapping between the specified pin (e.g., 8) and the actual Gumbi pin (e.g., 64) will be done automatically. If this is not defined, all specified pins will be considered absolute pin numbers on the Gumbi board. || Any numeric value less than or equal to the number of available I/O pins on the Gumbi board ||
|| ADDRESS || An ordered list of address bus pins, LSB first. || Any delimited list of pin numbers. Example: ADDRESS=1,2,3,4 ||
|| DATA || An ordered list of data bus pins, LSB first. || Any delimited list of pin numbers. Example: DATA=1,2,3,4 ||
|| VCC || An ordered list of pins that should be explicitly pulled high. || Any delimited list of pin numbers. Example: VCC=1,2,3,4 ||
|| GND || An ordered list of pins that should be explicitly pulled low. || Any delimited list of pin numbers. Example: GND=1,2,3,4 ||
|| CE || The Chip Enable pin, and its active state (0 is active low, 1 is active high). If specified, this pin is automatically asserted when initializing the Gumbi board in parallel mode. || A delimited pin number and active state value. Example: CE=21:0 ||
|| WE || The Whip Enable pin, and its active state (0 is active low, 1 is active high). If specified, this pin is automatically asserted when writing data in parallel mode. || A delimited pin number and active state value. Example: WE=21:0 ||
|| RE || The Rhip Enable pin, and its active state (0 is active low, 1 is active high). If specified, this pin is automatically asserted when reading data in parallel mode. || A delimited pin number and active state value. Example: RE=21:0 ||
|| OE || The Output Enable pin, and its active state (0 is active low, 1 is active high). If specified, this pin is automatically asserted when reading data in parallel mode. || A delimited pin number and active state value. Example: RE=21:0 ||
|| BE || The Byte Enable pin and its active state (0 is active low, 1 is active high), for chips that support both word (16 bit) and byte (8 bit) data busses. If specified, this pin is automatically asserted if  8 or fewer DATA pins are specified in parallel mode. || A delimited pin number and active state value. Example: BE=21:0 ||

= Instantiating the Configuration Class =

If using a built-in mode, such as the GPIO or Parallel modes, you do not need to instantiate the Configuration class directly; the class constructors for these modes will do this for you.

The Configuration class requires two arguments: 

  # The path to a configuration file
  # The mode of operation

The mode is simply a text string, which must match the value for the MODE key in the configuration file, if one is specified. This is to help applications quickly identify an incorrect configuration file.

If a MODE value is specified in the configuration file and it does not match the string passed to the Configuration class, an exception will be raised. If no MODE is specified in the configuration file, the mode value will be ignored.

Example:

{{{
from gumbi import Configuration

conf = Configuration("configs/my.conf", "GPIO")
}}}

= Accessing Key Values =

You can access specific key values using the GetSetting method:

{{{
print "Foo setting:", conf.GetSetting("FOO")[0]
}}}

Note that all values are stored as lists, so GetSetting will return a list on success, or None on failure.

= Setting Key Values =

You can explicitly set key values using the SetSetting method:

{{{
conf.SetSetting("FOO", ["bar2"])
}}}

Note that all values are stored as lists, so your value should always be a list.

= Setting Commands = 

Because the COMMANDS field - a list of address/data values that need to be written prior to a read or write operation - is a common field that needs to be changed, there is a convenience function for doing so:

{{{
conf.SetCommands([0x5555, 0xAA])
}}}

Alternatively, you can specify the name of an existing configuration key, and the COMMANDS value will be set to the value of that key:

{{{
conf.SetCommands("ERASE")
}}}